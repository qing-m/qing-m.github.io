{"pages":[{"title":"alone","text":"Alonehexo Alone","link":"/alone/index.html"},{"title":"","text":"ABOUT","link":"/about/index.html"}],"posts":[{"title":"Vue初始化过程","text":"理解Vue源码。初始化过程篇 目标深入理解vue初始化过程，彻底了解 new Vue(options) 时发生了什么 源码解读，Vue初始化过程Tip：在开始之前我们将Vue源码中package.json文件的script中的dev命令添加- -sourcemap，这样就可以在浏览器调试源码时查看当前代码在源码中的位置。 src/core/instance/index.js 123456789101112import { initMixin } from './init'// Vue 构造函数function Vue (options) { // 调用 Vue.prototype._init 方法，该方法是在 initMixin 中定义的 this._init(options)}// 定义 Vue.prototype._init 方法initMixin(Vue)export default Vue Vue.prototype._init src/core/instance/init.js 从这里我们可以看到，initMixin方法的参数是Vue构造函数，接着将 _init方法绑定在了Vue构造函数的原型上，并接受一个参数options，即new Vue时传过来的对象。 123456export function initMixin (Vue) { // 将_init方法绑定在Vue构造函数的原型上 Vue.prototype._init = function (options) { ...... }} 接下来我们就看一下 _init方法中发生了什么？这里就是new Vue的时候发生的事情。 1234567891011121314151617181920212223242526272829303132let uid = 0Vue.prototype._init = function (options) { // vue实例 const vm: Component = this // 没个vue实例都有一个_uid,并且是依次递增的 vm._uid = uid++ // 像有 istanbul ignore if 注释的, 这里使用了代码覆盖率工具，我们就忽略它，删掉也不会影响阅读源码。 // a flag to avoid this being observed vm._isVue = true // 处理组件配置项 if (options &amp;&amp; options._isComponent) { // 每个子组件初始化过程都走这里，这里之做了一些性能优化 // 子组件处理：性能优化 减少原型链的查找，提高执行效率 initInternalComponent(vm, options) } else { // 根组件处理： 进行选项合并, 将全局配置选项合并到跟组件的局部配置上 // 组件合并选项其实发生在三个地方： // 1. Vue.component(componentName: comp), 做了合并选项，合并的 Vue 内置的组件和用户自定义的全局组件。最终会放到全局的components选项中 // 2. { components: {xxx} } 局部注册组件， 执行编译器生成的 render 函数时做了合并选项， 会合并到全局配置项到组件局部配置项 // 3. 这里的根组件情况 vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || {}, vm ) }} 我们来看一下resolveConstructorOptions这个方法 1234567891011121314151617181920212223242526272829303132// 从构造函数上解析配置项export function resolveConstructorOptions (Ctor: Class&lt;Component&gt;) { // 从实例构造函数上获取选项 let options = Ctor.options // 如果构造函数有super函数 代表这个选项上还有基类， 即Vue.extend构建的子类 递归处理 if (Ctor.super) { // 递归 获取基类上的选项 const superOptions = resolveConstructorOptions(Ctor.super) // 缓存 缓存基类上的选项 const cachedSuperOptions = Ctor.superOptions if (superOptions !== cachedSuperOptions) { // 如果不一样 说明基类的选项发生了更改 // super option changed, // need to resolve new options. Ctor.superOptions = superOptions // check if there are any late-modified/attached options (#4976) // 找到更改的选项 const modifiedOptions = resolveModifiedOptions(Ctor) // update base extend options if (modifiedOptions) { // 将更改的选项喝 extend 选项合并 extend(Ctor.extendOptions, modifiedOptions) } // 将新的选项复制给options options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions) if (options.name) { options.components[options.name] = Ctor } } } return options} resolveModifiedOptions 12345678910111213141516// 解析构造函数选项中后续被修改或者增加的选项function resolveModifiedOptions (Ctor: Class&lt;Component&gt;): ?Object { let modified // 构造函数选项 const latest = Ctor.options // 密封的构造函数选项，备份 const sealed = Ctor.sealedOptions // 对比两个选项，记录不一致的选项 for (const key in latest) { if (latest[key] !== sealed[key]) { if (!modified) modified = {} modified[key] = latest[key] } } return modified} mergeOptions /src/core/util/options.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 合并两个选项，出现相同配置项时，子选项会覆盖父选项的配置 */export function mergeOptions ( parent: Object, child: Object, vm?: Component): Object { if (process.env.NODE_ENV !== 'production') { checkComponents(child) } if (typeof child === 'function') { child = child.options } // 标准化 props、inject、directive 选项，方便后续程序的处理 normalizeProps(child, vm) normalizeInject(child, vm) normalizeDirectives(child) // 处理原始 child 对象上的 extends 和 mixins，分别执行 mergeOptions，将这些继承而来的选项合并到 parent // mergeOptions 处理过的对象会含有 _base 属性 if (!child._base) { if (child.extends) { parent = mergeOptions(parent, child.extends, vm) } if (child.mixins) { for (let i = 0, l = child.mixins.length; i &lt; l; i++) { parent = mergeOptions(parent, child.mixins[i], vm) } } } const options = {} let key // 遍历 父选项 for (key in parent) { mergeField(key) } // 遍历 子选项，如果父选项不存在该配置，则合并，否则跳过，因为父子拥有同一个属性的情况在上面处理父选项时已经处理过了，用的子选项的值 for (key in child) { if (!hasOwn(parent, key)) { mergeField(key) } } // 合并选项，childVal 优先级高于 parentVal function mergeField (key) { // strats = Object.create(null) const strat = strats[key] || defaultStrat // 值为如果 childVal 存在则优先使用 childVal，否则使用 parentVal options[key] = strat(parent[key], child[key], vm, key) } return options} 重点12345678910111213141516171819202122232425262728293031323334353637383940Vue.prototype._init = function (options?: Object) { // expose real self vm._self = vm // 重点，整个初始化最重要的部分，也是核心 // 组件关系属性的初始化，比如：$parent $root $children initLifecycle(vm) // 初始化自定义事件 // &lt;comp @click='handleClcikSumb'&gt;&lt;/comp&gt; // 组件上的事件监听是自己在监听，谁触发谁监听 // 编译：this.$emit('click'), this.$on('click', handleClickSumb) initEvents(vm) // 初始化插槽， 获取 this.$slots, 定义 this._c 即 createElement 方法。即平时使用的 h 函数 initRender(vm) // 执行 beforeCreate 生命周期函数 // 也就是说 在beforeCreate时访问不了props,computed,data,watch等选项 callHook(vm, 'beforeCreate') // 初始化 inject 选项 得到 result[key] = val 形式的配置对象，并做响应式处理 initInjections(vm) // resolve injections before data/props // 响应式原理核心。处理 props，computed，data，watch，methods等选项 initState(vm) // 处理 provide 选项 // 总结 provide，inject 的实现原理 initProvide(vm) // resolve provide after data/props // 调用create生命周期钩子函数 callHook(vm, 'created') // 如果存在 el 属性 则自动执行 $mount if (vm.$options.el) { vm.$mount(vm.$options.el) } } 总结Vue 的初始化过程（new Vue(options)）都做了什么？ 处理组件配置项 初始化组件实例的关系属性，比如 $parent、$children、$root、$refs 等 处理自定义事件 调用 beforeCreate 钩子函数 初始化组件的 inject 配置项，得到 ret[key] = val 形式的配置对象，然后对该配置对象进行浅层的响应式处理（只处理了对象第一层数据），并代理每个 key 到 vm 实例上 数据响应式，处理 props、methods、data、computed、watch 等选项 解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上 调用 created 钩子函数 如果发现配置项上有 el 选项，则自动调用 $mount 方法，也就是说有了 el 选项，就不需要再手动调用 $mount 方法，反之，没提供 el 选项则必须调用 $mount 接下来进入挂载阶段","link":"/2022/02/09/Vue%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/"},{"title":"Vue响应式原理","text":"理解 Vue 源码。响应式原理篇 前言UI=render(state)上述公式中：state 是输入，UI 是输出。状态 state 一代变化，页面输出也随之变化。我们把这称之为数据驱动视图。state 和 UI 都是用户定的，而不变的是 render，所以 Vue 就充当了这个 render 的角色。 变化侦测变化侦测就是追踪状态，亦或者说是数据的变化，一旦发生了变化，就要去更新视图。那么 Vue 怎么知道数据发生了变化的呢？ 使 Object 数据变得可观测要想知道数据什么时候被读取了或数据什么时候被改写了，其实不难，JS 为我们提供了 Object.defineProperty 方法，通过该方法我们就可以轻松的知道数据在什么时候发生变化。 首先我们定义一个对象 product。 1234const product = { apple: 50, banana: 100,}; 我们定义这个对象 product 中，我们可以通过product.apple和product.banana来访问苹果和香蕉的价格。但是，我们并不知道这个对象的属性什么时候被修改和读取的。 接下来，我们使用 Object.defineProperty 来改写上面的例子。 1234567891011121314151617let product = {};let val = 50;Object.defineProperty(product, &quot;apple&quot;, { enumerable: true, //当且仅当该属性的 enumerable 键值为 true 时，该属性才会出现在对象的枚举属性中 configurable: true, // 当且仅当该属性的 configurable 键值为 true 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。 get() { console.log(&quot;apple属性被读取了&quot;); return val; }, set(newVal) { console.log(&quot;apple属性被修改了&quot;); val = newVal; },});console.log(product.apple);product.apple = 100;console.log(product.apple); 通过**Object.defineProperty()的方法给 product 定义一个 apple 属性，并且把这个属性的读和写分别用get()和set()进行拦截，每当属性被访问或修改都能触发get()和set()**。如下图 可以看到 product 可以主动告诉我们它属性的读写情况，这个 product 对象已经是“可观测的了” 为了把所有对象变成可观测对象，我们可以写以下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 源码位置：src/core/observer/index.js/** * Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象 */export class Observer { constructor(value) { this.value = value; // 给value新增一个__ob__属性，值为该value的Observer实例 // 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作 def(value, &quot;__ob__&quot;, this); if (Array.isArray(value)) { // 当value为数组时的逻辑 // ... } else { this.walk(value); } } walk(obj: Object) { const keys = Object.keys(obj); for (let i = 0; i &lt; keys.length; i++) { defineReactive(obj, keys[i]); } }}/** * 使一个对象转化成可观测对象 * @param { Object } obj 对象 * @param { String } key 对象的key * @param { Any } val 对象的某个key的值 */function defineReactive(obj, key, val) { // 如果只传了obj和key，那么val = obj[key] if (arguments.length === 2) { val = obj[key]; } if (typeof val === &quot;object&quot;) { // 如果属性也是对象，则进行递归 new Observer(val); } Object.defineProperty(obj, key, { enumerable: true, configurable: true, get() { console.log(`${key}属性被读取了`); return val; }, set(newVal) { if (val === newVal) { return; } console.log(`${key}属性被修改了`); val = newVal; }, });} 在上面代码我们定义了Observer类，它将用于将正常的 Object 变成可观测的 Object 并且给 value 新增一个ob属性，值为该 value 的 Observer 实例。这个操作相当于为 value 打上标记，表示它已经被转化成响应式了，避免重复操作 然后判断数据的类型，只有 object 类型的数据才会调用walk将每一个属性转换成 getter/setter 的形式来侦测变化。 最后，在 defineReactive 中当传入的属性值还是一个 object 时使用 new observer（val）来递归子属性，这样我们就可以把 obj 中的所有属性（包括子属性）都转换成 getter/seter 的形式来侦测变化。 也就是说，只要我们将一个 object 传到 observer 中，那么这个 object 就会变成可观测的、响应式的 object。 我们就可以直接定义 1234let productor = new Observer({ apple: 100, banana: 200,}); 收集依赖什么是依赖？在上面我们让 Object 变得可侦测，我们就知道数据什么时候变化，当发生变化就去通知视图更新。视图那么大总不能都去通知一遍吧？这样肯定是不行的。所以，我们要视图里谁用到了这个数据就通知谁。换个说法就是谁依赖了这个数据就更新谁。我们给每个数据都建一个依赖数组(因为一个数据可能被多处使用)，谁依赖了这个数据(即谁用到了这个数据)我们就把谁放入这个依赖数组中，那么当这个数据发生变化的时候，我们就去它对应的依赖数组中，把每个依赖都通知一遍，告诉他们：”你们依赖的数据变啦，你们该更新啦！”。这个过程就是依赖收集 何时收集依赖、何时更新依赖在上面变化侦测中我们知道访问一个属性会触发 getter(),所以就在这里收集依赖，修改一个属性会触发 setter(),所以在这里通知更新。总结一句话就是：在 getter 中收集依赖，在 setter 中通知依赖更新 把依赖收集到哪里？我们应该为每一个数据都建立一个依赖管理器，把这个数据所有的依赖都管理起来。OK，到这里，我们的依赖管理器 Dep 类应运而生，代码如下 123456789101112131415161718192021222324252627282930313233343536373839// 源码位置：src/core/observer/dep.jsexport default class Dep { constructor() { this.subs = []; } addSub(sub) { this.subs.push(sub); } // 删除一个依赖 removeSub(sub) { remove(this.subs, sub); } // 添加一个依赖 depend() { if (window.target) { this.addSub(window.target); } } // 通知所有依赖更新 notify() { const subs = this.subs.slice(); for (let i = 0, l = subs.length; i &lt; l; i++) { subs[i].update(); } }}/** * Remove an item from an array */export function remove(arr, item) { if (arr.length) { const index = arr.indexOf(item); if (index &gt; -1) { return arr.splice(index, 1); } }} 在上面的依赖管理器 Dep 类中，我们先初始化了一个 subs 数组，用来存放依赖，并且定义了几个实例方法用来对依赖进行添加，删除，通知等操作 有了依赖管理器后，我们就可以在 getter 中收集依赖，在 setter 中通知依赖更新了，代码如下 123456789101112131415161718192021222324function defineReactive(obj, key, val) { if (arguments.length === 2) { val = obj[key]; } if (typeof val === &quot;object&quot;) { new Observer(val); } const dep = new Dep(); //实例化一个依赖管理器，生成一个依赖管理数组dep Object.defineProperty(obj, key, { enumerable: true, configurable: true, get() { dep.depend(); // 在getter中收集依赖 return val; }, set(newVal) { if (val === newVal) { return; } val = newVal; dep.notify(); // 在setter中通知依赖更新 }, });} 在上述代码中，我们在 getter 中调用了 dep.depend() 方法收集依赖，在 setter 中调用 dep.notify() 方法通知所有依赖更新。 依赖到底是谁？虽然我们一直在说”谁用到了这个数据谁就是依赖“，但是这仅仅是在口语层面上，那么反应在代码上该如何来描述这个”谁“呢？ 其实在 Vue 中还实现了一个叫做Watcher的类，而Watcher类的实例就是我们上面所说的那个”谁”。换句话说就是：谁用到了数据，谁就是依赖，我们就为谁创建一个Watcher实例。在之后数据变化时，我们不直接去通知依赖更新，而是通知依赖对应的Watcher实例，由Watcher实例去通知真正的视图。 Watcher类的具体实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142export default class Watcher { constructor(vm, expOrFn, cb) { this.vm = vm; this.cb = cb; this.getter = parsePath(expOrFn); this.value = this.get(); } get() { window.target = this; const vm = this.vm; let value = this.getter.call(vm, vm); window.target = undefined; return value; } update() { const oldValue = this.value; this.value = this.get(); this.cb.call(this.vm, this.value, oldValue); }}/** * Parse simple path. * 把一个形如'data.a.b.c'的字符串路径所表示的值，从真实的data对象中取出来 * 例如： * data = {a:{b:{c:2}}} * parsePath('a.b.c')(data) // 2 */const bailRE = /[^\\w.$]/;export function parsePath(path) { if (bailRE.test(path)) { return; } const segments = path.split(&quot;.&quot;); return function (obj) { for (let i = 0; i &lt; segments.length; i++) { if (!obj) return; obj = obj[segments[i]]; } return obj; };} 谁用到了数据，谁就是依赖，我们就为谁创建一个 Watcher 实例，在创建 Watcher 实例的过程中会自动的把自己添加到这个数据对应的依赖管理器中，以后这个 Watcher 实例就代表这个依赖，当数据变化时，我们就通知 Watcher 实例，由 Watcher 实例再去通知真正的依赖 那么，在创建 Watcher 实例的过程中它是如何的把自己添加到这个数据对应的依赖管理器中呢？ 下面我们分析 Watcher 类的代码实现逻辑： 当实例化 Watcher 类时，会先执行其构造函数; 在构造函数中调用了 **this.get()**实例方法； 在 get() 方法中，首先通过 window.target = this 把实例自身赋给了全局的一个唯一对象 window.target 上，然后通过 let **value = this.getter.call(vm, vm)**获取一下被依赖的数据，获取被依赖数据的目的是触发该数据上面的 getter，上文我们说过，在 getter 里会调用 **dep.depend()**收集依赖，而在 **dep.depend()**中取到挂载 window.target 上的值并将其存入依赖数组中，在 get()方法最后将 window.target 释放掉。 而当数据变化时，会触发数据的 setter ，在 setter 中调用了 dep.notify()方法，在 dep.notify()方法中，遍历所有依赖(即 watcher 实例)，执行依赖的 update()方法，也就是 Watcher 类中的 update()实例方法，在 update()方法中调用数据变化的更新回调函数，从而更新视图。 简单总结一下就是：Watcher 先把自己设置到全局唯一的指定位置（window.target），然后读取数据。因为读取了数据，所以会触发这个数据的 getter。接着，在 getter 中就会从全局唯一的那个位置读取当前正在读取数据的 Watcher，并把这个 watcher 收集到 Dep 中去。收集好之后，当数据发生变化时，会向 Dep 中的每个 Watcher 发送通知。通过这样的方式，Watcher 可以主动去订阅任意一个数据的变化。为了便于理解，我们画出了其关系流程图，如下图： 不足之处虽然我们通过 Object.defineProperty 方法实现了对 object 数据的可观测，但是这个方法仅仅只能观测到 object 数据的取值及设置值，当我们向 object 数据里添加一对新的 key/value 或删除一对已有的 key/value 时，它是无法观测到的，导致当我们对 object 数据添加或删除值时，无法通知依赖，无法驱动视图进行响应式更新。 流程 Data通过Observer将属性转化为getter/setter的形式来追踪变化 当外界通过 Watcher 读取数据时，会触发getter，从而将Watcher添加到依赖中 当数据发生了变化时，会触发setter，从而向Dep中的依赖（即 Watcher）发送通知。 Watcher接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。","link":"/2022/02/09/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"},{"title":"Vue异步更新","text":"理解Vue源码。异步更新篇","link":"/2022/02/09/Vue%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0/"},{"title":"JavaScript原型链","text":"面不到也要懂 简介JavaScript 万物皆为对象为什么称为原型链呢？链字面意思：链是汉语汉字，拼音 liàn，是指用金属的环连接成的长条形的东西。从字面意思来讲就是一个有头有尾的，能链接在一起的长条。但是 js 的原型链是不连结在一起的，它就是一个长条。长条的尾部连结的为 null Object 引用类型：Object、Array、Function、Date、RegExp。 引用类型，都具有对象特性，即可自由扩展属性。 引用类型，都有一个隐式原型 __proto__ 属性，属性值是一个普通的对象。 引用类型，隐式原型 __proto__ 的属性值指向它的构造函数的显式原型 prototype 属性值。 当你试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么它会去它的隐式原型 __proto__。也就是它的构造函数的显示原型 prototype 中寻找 我们也可以将__proto__当作链接的纽带，就是它将 js 原型组成了一条链。 总结上面我们说到，原型链的尾部为null所以 Object.prototype 指向为 null。加上纽带链接起来即：Object.prototype.__proto__ = null 类 Foo123456class Foo { constructor(name) { this.name = name; }}// console.log(Foo.prototype.__proto__ === Object.prototype); // true 当一个类为头部时，它的原型链为：Foo.prototype.__proto__ =&gt; Object.Prototype 实例123456789class Foo { constructor(name) { this.name = name; }}const f1 = new Foo(&quot;胖虎&quot;);// console.log(f1.__proto__ === Foo.prototype); // true 当一个实例为头部时，它的原型链为：f1.__proto__ =&gt; Foo.prototype","link":"/2022/02/23/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"title":"Markdown基本语法","text":"Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。优点：1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。2、操作简单缺点：1、需要记一些语法（当然这也是很简单的事情！） 一、标题的使用在想要设置为标题的文字前面加#来表示(注意后面的空格)一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 示例： 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 展示效果： 一级标题二级标题三级标题四级标题五级标题六级标题 二、字体加粗要加粗的文字左右分别用两个号包起来斜体要倾斜的文字左右分别用一个号包起来斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来删除线要加删除线的文字左右分别用两个~~号包起来 示例： 1234**加粗的文字***倾斜的文字*`***斜体加粗的文字***~~加删除线的文字~~ 展示：加粗的文字倾斜的文字`斜体加粗的文字加删除线的文字 三、引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt; ….n个 示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;这是引用的内容 展示： 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线三个或者三个以上的 - 或者 * 都可以。 示例： 1234-------******** 展示： 五、图片语法： 1234![图片alt](图片地址 ''图片title'')图片alt就是显示在图片下面的文字，相当于对图片内容的解释。也是图片加载失败所显示的图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 12![warning](warning.jpg &quot;图片描述&quot;)![warning](sample.jpg &quot;图片的描述&quot;) 到图片上时显示的内容。title可加可不加 效果如下： markdown格式追求的是简单、多平台统一。那么图片的存储就是一个问题，需要用图床，提供统一的外链，这样就不用在不同的平台去处理图片的问题了。才能做到书写一次，各处使用。 六、超链接语法： 12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例： langmarkdown12[百度](https://www.baidu.com &quot;百度&quot;)[Hexo](https://hexo.io/zh-cn/ &quot;Hexo&quot;) 展示：百度Hexo 七、列表无序列表 语法： 无序列表用 - + * 任何一种都可以注意：- + * 跟内容之间都要有一个空格 123- 列表内容+ 列表内容* 列表内容 展示： 列表内容 列表内容 列表内容 有序列表 语法： 数字加点 1231. 列表内容2. 列表内容3. 列表内容 展示： 列表内容 列表内容 列表内容 列表嵌套 语法： 12345- 列表1 - 列表1-1 - 列表1-1-1 - 列表1-2 - 列表1-3 展示： 列表1 列表1-1 列表1-1-1 列表1-2 列表1-3 八、表格语法： 123456789| 表头 | 表头 | 表头 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |第二行分割表头和内容。文字默认居左-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐:-: 设置内容和标题栏居中对齐 示例： 1234| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 | 效果： 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 九、代码单行代码 语法：代码之间分别用一个反引号包起来 1`console.log('我是JavaScript呀(*^(|~|)^*)')` 效果：console.log('我是JavaScript呀(*^(|~|)^*)') 代码区块 你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）： langmarkdown1123$(document).ready(function () { alert('RUNOOB');}); 效果： 123$(document).ready(function () { alert('RUNOOB');}); 十、流程图语法： 1234567```mermaidgraph LRA[方形] --&gt;B(圆角) B --&gt; C{条件a} C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图]``` 效果：本网站解析不了所以放的图片","link":"/2021/10/29/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"title":"Git使用规范流程","text":"简介团队开发中，遵循一个合理、清晰的Git使用流程，是非常重要的。否在，每个人都提交一堆commit，项目就会变得难以维护。所以我们在团队开发中要遵守一个规范使用Git，下面就是我在开发中使用Git的一些心得体会，在自己的网站记录一下。 熟悉Git的常用命令Git常用的8个命令 git clonegit clone [ url ] 拷贝一个 Git 仓库到本地，让自己能够查看该项目，或者进行修改。url是你要拷贝的项目地址。 git checkoutgit checkout 用于切换到其它分支，加上-b就是创建并切换到分支。 git branchgit branch 查看分支，-a 查看所有分支，-r查看远程分支。 git addgit add 将文件添加到暂存区。 git commitgit commit 将暂存区内容添加到本地仓库中。 git pushgit push 命用于从将本地的分支版本上传到远程并合并。 git pullgit pull 命令用于从远程获取代码并合并本地的版本。 git mergegit merge 命令是用于将两个或两个以上的开发历史合并在一起的操作 流程产品提出一个需求，现在要我来写这个需求，我会先这样做。 首先 使用git clone [项目地址] 这个命令把远程仓库的项目拉到本地。如果本地已经存在这个项目，就用git chekout master切换到主分支，然后使用git pull origin masger去拉去远程仓库最新的代码，将本地项目更新。 当我们切换到主分支并且代码是最新时，我们就可以进行下一步操作。首先使用git checkout -b dev_2021_11_01_test基于master分支上创建一个新分支并切换到这个分支。这样做的目的就是避免master分支上的代码被污染，因为我们写完需要进行测试，如果在master分支上直接提交推送，碰见bug不能说GG了，也有得麻烦（吃过亏上过当就老实了O(∩_∩)O!!） 当我们创建好一个分支后我们就可以在这个分支上写代码了。 需求写好了，我们接下来就要把代码推送到远端仓库中。首先使用git add –all把所有更改得文件都添加到暂存区，接着使用git commit -m ‘提交信息，，比如你做了什么在这次提交当中’将暂存区内容添加到本地仓库中。接着使用git push -u origin 分支名称 将本地的分支版本上传到远程并合并。 写完代码我们还要经过测试才能进行发布，在这里，我们得测试分支就为uat。首先我们切换到uat分支git checkout uat,然后进行git pull拉取uat远端最新代码，接着执行git merge dev_2021_11_01_test将我们在dev_***分支写的代码合并到uat上面，然后进行部署、测试。 总结Git使用流程也就这么多，不要想的很复杂。鄙人博客写的很少，也是进行记录，所以写的不是很好，各位看官如果觉得不好可以在下发评论，也算是对我的监督。有空的时候我就会写文章，提高自己的语言组织能力和技巧，加油！！！！","link":"/2021/11/01/Git%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"title":"手写一个Promise","text":"由浅入深实现符合Promise A+规范的Promise代码 实现简单版(非异步)123456789101112131415161718const p1 = new Promise((resolve,reject) =&gt; { console.log('1') resolve('成功') reject('失败') throw new Error('发生错误')})console.log(2)p1.then(data =&gt; { console.log('success', data)}, err =&gt; { console.log('failed', err)})// 保留resolve 输出结果 1 2 success 成功// 保留reject 输出结果 1 2 failed 失败// 保留throw new Error 输出结果 1 2 failed 发生错误 总结 传入Promise构造函数的executor是立即执行函数 then方法是promise对象上的方法，并接收两个函数:onFufilled, onRejected onFufilled接收参数value, onRejected接收参数reason, 并且值是由resolve和reject传递过来的，由此可见，value和reason也是构造函数上的属性 当调用了resolve方法后，promise状态由pending改为resolved且不能再被更改，同理reject 抛出错误后，同样会走reject方法，reason由onRejected方法打印 由上所述，我们可以写出以下代码 1234567891011121314151617181920212223242526272829303132333435363738394041const RESOLVED = 'RESOLVED'const REJECTED = 'REJECTED'const PENDING = 'PENDING'class Promise { constructor(executor) { this.status = PENDING this.value = undefined this.reason = undefined let resolve = (value) =&gt; { if(this.status === PENDING) { this.status = RESOLVED this.value = value } }; let reject = (reason) =&gt; { if(this.status === PENDING) { this.status = REJECTED this.reason = reason } }; try { executor(resolve, reject) }catch(error) { reject(error) }; } then(onFufilled, onRejected) { if(this.status === RESOLVED) { onFufilled(this.value) } if(this.status === REJECTED) { onRejected(this.reason) } }} 考虑executor执行异步函数的情况有如下代码： 12345678910111213const p1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('成功') }, 1000)})p1.then(data =&gt; { console.log('success', data)}, err =&gt; { console.log('failed', err)})// 无结果输出 分析 当JavaScript主线程执行到executor，setTimeout作为宏观任务被暂时储存，按照主线程 =&gt; 微观任务 =&gt; 宏观任务的事件循环顺序执行 此时执行到then，由于没有调用resolve，所以status的状态为pending，所以上面的代码什么也不会输出。 解决 创建两个数组onResolvedCallbacks、onRejectedCallbacks。excutor执行异步代码时，在then里增加判断，如果状态为pending，就将onFufilled和onRejected分别存入onResolvedCallbacks和onRejectedCallbacks，当异步代码被执行完毕，调用resolve或reject的时候，从数组里面取出，依次执行。 由上所述，添加以下代码 12345678910111213141516171819202122232425262728293031323334353637383940constructor(executor) { ... // 成功存放的数组 this.onResolvedCallbacks = [] // 失败存放的数组 this.onRejectedCallbacks = [] let resolve = (value) =&gt; { if(this.status === PENDING) { this.status = RESOLVED this.value = value // 一旦resolve执行，调用成功数组的函数 this.onResolvedCallbacks.forEach(fn =&gt; fn()) } } let resolve = (reason) =&gt; { if(this.status === PENDING) { this.status = REJECTED this.reason = reason // 一旦reject执行，调用失败数组的函数 this.onRejectedCallbacks.forEach(fn =&gt; fn()) } } ...}then(onFufilled, onRejected) { ... if(this.status === PENDING) { this.onResolvedCallbacks.push(() =&gt; { onFufilled(this.value) }) this.onRejectedCallbacks.push(() =&gt; { onRejected(this.reason) }) }} 实现Promise的链式调用有如下代码： 12345678910111213141516171819// 原生的Promiseconst p1 = new Promise((resolve,reject) =&gt; { setTimeout(() =&gt; { &lt;!-- resolve('成功') --&gt; reject('失败') // resolve或reject }, 1000);}).then(data =&gt; { console.log('success1', data) return 123}, err =&gt; { console.log('failed1', err) return 456}).then(data =&gt; { console.log('success2', data)}, err =&gt; { console.log('failed2', err)})// 输出结果： failed1 失败 success2 456 分析 当promise被reject后，第一个then打印没有问题，但是第二个then被onFufilled打印了，证明此时是resolved状态，如果链式调用返回this的话，promise状态应该不会改变，仍然是rejected才对，由此可见，链式调用每次都会返回一个新的promise 由上稍微改下代码： 1234567891011121314151617181920212223242526...then(onFufilled, onRejected) { let promise2 = new Promise((resolve, reject) =&gt; { if(this.status === RESOLVED) { let x = onFufilled(this.value) resolve(x) } if(this.status === REJECTED) { let x = onRejected(this.reason) resolve(x) } if(this.status === PENDING) { this.onResolvedCallbacks.push(() =&gt; { let x = onFufilled(this.value) resolve(x) }) this.onRejectedCallbacks.push(() =&gt; { let x = onRejected(this.reason) resolve(x) }) } }) return promise2} 到这里链式调用就可以跑了，效果和原生Promise一样 实现透传有如下代码： 1234567891011121314const p1 = new Promise((resolve, rject) =&gt; { setTimeout(() =&gt; { reslove('成功') reject('失败') }, 1000)})p1.then().then().then().then(data =&gt; { console.log('success', data)}, err =&gt; { console.log('failed', err)})// 输出：success 成功// 输出：failed 失败 分析 当resolve的时候，实际上可以看做123456789101112p1.then(v =&gt; { return v}).then(v =&gt; { return v}).then(v =&gt; { return v}).then(data =&gt; { console.log('success', data) }, err =&gt; { console.log('failed', err)}) 每次返回当前的data，直到最后被打印 当reject的时候，实际上可以看做123456789101112p1.then(()=&gt;{}, err =&gt; { throw err}).then(()=&gt;{}, err =&gt; { throw err}).then(()=&gt;{}, err =&gt; { throw err}).then(data =&gt; { console.log('success', data) }, err =&gt; { console.log('failed', err) }) 每次抛出当前错误，直到最后被打印 因此then方法稍微加点代码： 12345then(onFufilled, onRejected) { onFufilled = typeof onFufilled === 'function' ? onFufilled : v=&gt;v onRejected = typeof onRejected === 'function' ? onRejected : err =&gt; { throw err } ...} 如果X是一个Promise有如下代码： 12345678910111213const p1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(new Promise((resolve, reject) =&gt; { resolve('成功') })) }, 1000)})p1.then().then().then().then(data =&gt; { console.log('success', data)}, err =&gt; { console.log('failed', err)}) 此时需要特殊处理，调用传入的promise的then方法，构造resolve方法(规范中叫做y)，构造reject方法(规范中叫做r,)将value传入，递归下去。 重点 由于我们不确定resolve和reject的值类型，所以我们统一写一个方法去处理他们resolvePromise(promise2, x, resolve, reject)由于promise2在当前上下文无法获取到，所以包裹一个异步函数setTimeout，而异步函数抛错又无法被包裹在executor的trycatch捕获，所以再套一层trycatch 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152then(onFufilled, onRejected) { onFufilled = typeof onFufilled === 'function' ? onFufilled : v=&gt;v onRejected = typeof onRejected === 'function' ? onRejected : err =&gt; { throw err } let promise2 = new Promise((resolve, rject) =&gt; { if(this.status === RESOLVED) { setTimeout(() =&gt; { try { let x = onFufilled(this.value) resolvePromise(promise2, x, resolve, reject) }catch(error) { reject(error) } }) } if(this.status === REJECTED) { setTimeout(() =&gt; { try { let x = onRejected(this.reason) resolvePromise(promise2, x, resolve, reject) }catch(error) { reject(error) } }) } if(this.status === PENDING) { this.onResolvedCallbacks.push(() =&gt; { setTimeout(() =&gt; { try { let x = onFufilled(this.value) resolvePromise(promise2, x, resolve, reject) } catch (error) { reject(error) } },0) }) this.onRejectedCallbacks.push(() =&gt; { setTimeout(() =&gt; { try { let x = onRejected(this.reason) resolvePromise(promise2, x, resolve, reject) } catch (error) { reject(error) } },0) }) } }) return promise2} 至此，我们将处理x的逻辑统一到resolvePromise方法中处理 处理resolvePromise方如果promise2 === x首先，如果 promise2 === x，得抛个错出去。因为我自己不可能等我自己出门去买菜。demo如下： 12345678const p1 = new Promise((resolve,reject) =&gt; { resolve('成功') }) let p2 = p1.then(data =&gt; { return p2 }) // 输出：UnhandledPromiseRejectionWarning: TypeError: Chaining cycle detected for promise #&lt;Promise&gt; 这种情况我们需要和源码一样，抛出一个Chaining cycle detected for promise #的类型错误。 如果x是普通值如果x不是对象或者函数，证明是个普通值，普通值的话，直接调用promise2的resolve方法，返回就行此时我们的代码如下： 12345678910const resolvePromise = (promise2, x, resolve, reject) =&gt; { if(promise2 === x) { return reject(new TypeError('Chaining cycle detected for promise #&lt;Promise&gt;')) } if((typeof x === 'object' &amp;&amp; x != null) || typeof x === 'function') { } else { resolve(x) } } 如果x是对象或者函数如果x是对象或者函数,根据promiseA+规范，我们要let then = x.then并且要trycatch包裹他，因为要谨防别人手动定义then方法抛错比如以下代码： 123456let x = {}Object.defineProperty(x,'then',{ get() { throw new Error('错误') }}) 此时我们代码如下： 12345678910111213141516171819const resolvePromise = (promise2,x,resolve,reject) =&gt; { if(promise2 === x) { return reject(new TypeError('Chaining cycle detected for promise #&lt;Promise&gt;')) } if((typeof x === 'object' &amp;&amp; x != null) || typeof x === 'function') { try { let then = x.then if(typeof then === 'function') { }else { resolve(x) } }catch(error) { reject(error) } }else { resolve(x) }} 如果x是函数 关键点来了，根据A+规范，我们需要call一下then，并且this为x，resolvePromise的值为y, rejectPromise的值为r，有可能promise再套promise再套promise，所以这里我们需要递归处理,代码如下 1234567891011121314151617181920212223const resolvePromise = (promise2,x,resolve,reject) =&gt; { if(promise2 === x) { return reject(new TypeError('Chaining cycle detected for promise #&lt;Promise&gt;')) } if((typeof x === 'object' &amp;&amp; x != null) || typeof x === 'function') { try { let then = x.then if(typeof then === 'function') { then.call( x, y =&gt; { resolvePromise(promise2, y, resolve, reject) },r =&gt; { reject(r) }) }else { resolve(x) } }catch(error) { reject(error) } }else { resolve(x) }} 防止别人写的promise，既调用resolve,又调用reject至此我们已经实现了一个promise，只是还有点小瑕疵，因为我们必须谨防别人写的promise，不按照A+规范来，所以我们需要在上述代码里加一个小控制called。代码如下 1234567891011121314151617181920212223242526272829303132const resolvePromise = (promise2,x,resolve,reject) =&gt; { if(promise2 === x) { return reject(new TypeError('Chaining cycle detected for promise #&lt;Promise&gt;')) } if((typeof x === 'object' &amp;&amp; x != null) || typeof x === 'function') { let called try { let then = x.then if(typeof then === 'function') { then.call( x, y =&gt; { if(called) return called = true resolvePromise(promise2, y, resolve, reject) },r =&gt; { if(called) return called = true reject(r) }) }else { resolve(x) } }catch(error) { if(called) return called = true reject(error) } }else { resolve(x) }}// 只有x.then出错的时候也得控制一下，为了防止，下次别人在reject里调用resolve A+规范测试增加代码： 12345678Promise.defer = Promise.deferred = function () { let dfd = {} dfd.promise = new Promise((resolve,reject) =&gt; { dfd.resolve = resolve dfd.reject = reject }) return dfd } // 延迟对象，使我们在一般情况下，不用new Promise()，而是可以调用Promise.defer少嵌套一层 初始化npm: npm init -y 安装测试包：npm i promises-aplus-tests -S 修改package.json：”scripts”: { “test”: “promises-aplus-tests promise.js //你的文件名字—这是注释请删除” } 执行测试脚本： npm run test 测试结果","link":"/2021/11/01/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAPromise/"},{"title":"浏览器事件环","text":"浏览器的进程 每一个选项卡都是一个进程 这样就算一个页面卡死了也不会影响其他页卡 浏览器也有一个主进程（用户界面） 每个页卡里都有一个渲染进程（浏览器内核） 网络进程 GPU进程3d绘制 第三方插件的进程 渲染进程(包含多个线程) GUI渲染线程（渲染页面的 js引擎线程(他和页面渲染是互斥的) 当js线程执行时，渲染线程会停止，防止边渲染边改写页面。 js如果是多线程，会有相互干扰的问题，比方说同时进行页面组件的删除和增加，就会产生锁的问题 事件触发线程，他也是独立的线程（EventLoop） 事件click、setTimeout、ajax也是一个独立的线程 宏任务和微任务 只要我们创建一个线程，它执行就是异步的，异步的方法，划分出了两个概念，一个叫宏任务，一个叫微任务 宏任务: 一般宿主环境提供的异步方法，都是宏任务，比如setTimeout，script，ui渲染 微任务：一般由语言标准提供的异步方法，都是微任务，比如promise，mutationObserver EventLoop流程 事件环执行顺序 js引擎线程由上往下执行js代码，其中包含同步代码和异步代码，碰到异步代码，将Promise.then或者MutationObserver放入微任务队列，将ajax，setTimeout、event放入宏任务队列 同步代码执行完毕后，清空微任务队列，注意此时由与GUI渲染并未开始，所以页面并未被渲染 微任务被清空后，开始执行GUI渲染线程，渲染页面 渲染页面结束后，从宏任务队列中取出一个宏任务放入执行栈中执行 再次执行js引擎线程，重复以上步骤 样例一1234567document.body.style.background = 'red';console.log(1)Promise.resolve().then(() =&gt; { console.log(2) document.body.style = 'yellow'})console.log(3) 上述代码的执行顺序，按照上面的分析： 将body赋予red背景色 打印1,并且将Promise.then()放入微任务队列，接着往下执行，打印3 同步代码执行完毕，清空微任务队列，打印2，给body赋予yellow背景 微任务队列执行完毕，开始进行GUI渲染线程，渲染页面 所以最终结果为1，2，3，yellow色，并不会看见页面由red色变成yellow色，因为页面渲染的时候body已经是yellow色了 样例二1234567document.body.style.background = 'red'; console.log(1) setTimeout(() =&gt; { console.log(2) document.body.style.background = 'yellow'; },0) console.log(3); 上述代码的执行顺序，按照上面的分析： 将body赋予红色 打印出1，并且碰见一个setTimeout将它放入宏任务队列。 打印出3，同步代码执行完毕，清空微任务队列，（这个例子中没有微任务） 微任务队列清空后，进行GUI渲染线程，渲染页面，此时body为红色 页面渲染完毕后，从宏任务队列取出一个宏任务，此时打印2，并且继续执行流程，GUI渲染，页面变成黄色 所以我们最终控制台打印的是1，3，2，页面先看到红色，再看到黄色 样例三123456789101112Promise.resolve().then(() =&gt; { console.log('Promise1') setTimeout(() =&gt; { console.log('setTimeout2') }, 0); }) setTimeout(() =&gt; { console.log('setTimeout1'); Promise.resolve().then(() =&gt; { console.log('Promise2') }) }, 0); 上述代码的执行顺序，按照刚才的分析 js引擎线程将代码从上到下执行同步任务，碰到一个Promise1的微任务，将他放入微任务队列 接着碰见一个setTimeout1,将它放入宏任务队列 同步代码执行完毕，开始清空微任务队列，打印Promise1并将setTimeout2放入宏任务队列等待执行 微任务队列清空后，开始进行GUI渲染，由于代码没有改变样式的代码，所以没有变化 页面渲染完毕后，从宏任务队列取出一个宏任务执行，此时打印setTimeout1,并且将Promise2放入微任务队列 再次清空微任务队列打印Promise2 再次从宏任务队列中取出setTimeout2执行 所以我们最终控制台打印的是Promsie1,setTimeout1,Promise2,setTimeout2 样例四1234567891011121314151617console.log(1); async function async () { console.log(2); await console.log(3); console.log(4) } setTimeout(() =&gt; { console.log(5); }, 0); const promise = new Promise((resolve, reject) =&gt; { console.log(6); resolve(7) }) promise.then(res =&gt; { console.log(res) }) async (); console.log(8); 上述代码的执行顺序，按照刚才的分析 先执行同步代码，打印1，将5放入宏任务队列，打印6，将7放入微任务队列，执行async，打印2 await console.log(3)可以理解为123Promise.resolve(console.log(3)).then(() =&gt; { console.log(4)})， 所以打印3，并把4放入微任务队列 如果是node环境，代码会被解析成new Promise((resolve,reject) =&gt; {resolve(console.log(3))}).then(() =&gt; {console.log(4)}) 在我们这个例子中执行顺序不变，因为console.log(3)不是promise，如果这里换成微任务的话，执行顺序和浏览器中会有不同。 async()执行完毕打印8 清空微任务队列，打印7，4 最后从宏任务队列中取出5执行 所以我们最终控制台打印的是1，6，2，3，8，7，4，5 样例五123456789button.addEventListener('click',()=&gt;{ console.log('listener1'); Promise.resolve().then(()=&gt;console.log('micro task1')) }) button.addEventListener('click',()=&gt;{ console.log('listener2'); Promise.resolve().then(()=&gt;console.log('micro task2')) }) button.click(); // click1() click2() 上述代码的执行顺序，按照刚才的分析 button.click();同步代码执行到这里，相当于同步执行click1()click2()，此时打印listener1，microtask1放入微任务队列，打印listener2，micro task2放入微任务队列中 同步代码执行完毕后，清空微任务队列，打印micro task1 和micro task2 所以我们最终控制台打印的是listener1 listener2 micro task1 micro task2 如果是用户主动点击，click事件是宏任务，执行顺序有所不同： 用户点击后，会先后执行两个宏任务，click1和click2 此时就变成先打印listener1，再将micro task1放入微任务队列 清空微任务队列，打印micro task1 执行宏任务click2，打印listener2,打印micro task2 所以我们最终控制台打印的是listener1 micro task1 listener2 micro task2","link":"/2021/11/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E7%8E%AF/"},{"title":"发布订阅模式和观察者模式","text":"两个简单的demo说明发布订阅模式和观察者模式 发布订阅模式划重点 发布和订阅本身没有联系 发布订阅模式主要分为两部分：on和emit on就是把一些函数维护到一个数组中去 emit就是让数组中的方法依次执行 下面看一个简单的demo: 女朋友催我给她买包，催一次没用，当她催我第三次了，我才给她买. 12345678910111213141516171819202122232425262728293031323334const fs = require('fs')const path = reqire('path')let event = { arr: [], on(fn) { this.arr.push(fn) }, emit() { this.arr.foreach((fn) =&gt; fn()) }}let count = 0event.on(() =&gt; { console.log(`女朋友催了我第${++count}次`)})event.on(() =&gt; { console.log(`女朋友催了我第${++count}次`)})event.on(() =&gt; { console.log(`女朋友催了我第${++count}次`)})event.on(() =&gt; { console.log(`没办法了,催了${count}次，没钱也得买`)})event.emit()// 输出结果：// 女朋友催了我第1次// 女朋友催了我第2次// 女朋友催了我第3次// 没办法了，催了3次了，没钱也得给她买了 在上一篇手写promiseA+里，处理executor执行异步函数的地方，定义了两个数组onResolvedCallbacks和onRejectedCallbacks，当执行then，status处于pending状态的时候，分别往这两个数组里push onFufilled和onRejected函数，等到异步函数执行完，再取出来分别执行。vue对象和数组的依赖收集中，dep.depend()和dep.notify()，也是用了这种模式 观察者模式划重点 观察者模式，有观察者，就有被观察者 观察者需要放到被观察者中 被观察者的状态发生变化需要通知观察者 内部是基于发布订阅模式，收集观察者，状态变化后要通知观察者 下面看一个简单的demo：被观察者小猫，观察者铲屎官1和铲屎官2，小猫饿了要通知铲屎官1和铲屎官2泡奶 123456789101112131415161718192021222324252627282930class Subject { constructor(name) { this.name = name this.state = '肚子很饱' this.observers = [] } attach(o) { this.observers.push(o) } setState(newState) { this.state = newState this.observers.forEach(o =&gt; o.update(this)) } } class Observer { constructor(name) { this.name = name } update(o) { console.log(`${this.name}被通知了，小猫现在要${o.state}`) } } let baby = new Subject('小猫') let people1 = new Observer('铲屎官1') let people2 = new Observer('铲屎官2') baby.attach(people1) baby.attach(people2) baby.setState('吃奶') // 铲屎官1被通知了，小猫现在要吃奶 // 铲屎官2被通知了，小猫现在要吃奶 在vue中，vue对象和数组的依赖收集中，dep和watcher相互通知，就使用了观察者模式。","link":"/2021/11/18/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Vue源码","slug":"Vue源码","link":"/tags/Vue%E6%BA%90%E7%A0%81/"},{"name":"JavaScript原型","slug":"JavaScript原型","link":"/tags/JavaScript%E5%8E%9F%E5%9E%8B/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"宏任务","slug":"宏任务","link":"/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1/"},{"name":"微任务","slug":"微任务","link":"/tags/%E5%BE%AE%E4%BB%BB%E5%8A%A1/"},{"name":"发布订阅模式","slug":"发布订阅模式","link":"/tags/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"},{"name":"观察者模式","slug":"观察者模式","link":"/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"源码","slug":"源码","link":"/categories/%E6%BA%90%E7%A0%81/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"工具类","slug":"工具类","link":"/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"深入理解源码","slug":"深入理解源码","link":"/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%BA%90%E7%A0%81/"},{"name":"怎样存在的","slug":"怎样存在的","link":"/categories/%E6%80%8E%E6%A0%B7%E5%AD%98%E5%9C%A8%E7%9A%84/"},{"name":"开发模式","slug":"开发模式","link":"/categories/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/"}]}