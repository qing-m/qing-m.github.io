---
title: 浏览器事件环
categories:
  - 怎样存在的
tags:
  - JavaScript
  - 宏任务
  - 微任务
date: 2021-11-17 16:34:58
toc: true
---
# 浏览器的进程
* 每一个选项卡都是一个进程
  * 这样就算一个页面卡死了也不会影响其他页卡
* 浏览器也有一个主进程（用户界面）
* 每个页卡里都有一个渲染进程（浏览器内核）
* 网络进程
* **GPU**进程**3d**绘制
* 第三方插件的进程

<!-- more -->

# 渲染进程(包含多个线程)
* **GUI**渲染线程（渲染页面的
* **js**引擎线程(他和页面渲染是互斥的)
  * **当js线程执行时，渲染线程会停止，防止边渲染边改写页面。**
  * **js如果是多线程，会有相互干扰的问题，比方说同时进行页面组件的删除和增加，就会产生锁的问题**
* 事件触发线程，他也是独立的线程（**EventLoop**）
* 事件**click、setTimeout、ajax**也是一个独立的线程
  
# 宏任务和微任务
> 只要我们创建一个线程，它执行就是异步的，异步的方法，划分出了两个概念，一个叫宏任务，一个叫微任务

* **宏任务**: 一般宿主环境提供的异步方法，都是宏任务，比如**setTimeout，script，ui渲染**
* **微任务**：一般由语言标准提供的异步方法，都是微任务，比如**promise，mutationObserver**

# EventLoop流程
{% asset_img EventLoop.jpg image %}

## 事件环执行顺序
1. **js**引擎线程由上往下执行**js**代码，其中包含同步代码和异步代码，碰到异步代码，将**Promise.then**或者**MutationObserver**放入**微任务**队列，将**ajax，setTimeout、event**放入**宏任务**队列
2. 同步代码执行完毕后，清空微任务队列，注意此时由与**GUI渲染**并未开始，所以页面并未被渲染
3. 微任务被清空后，开始执行**GUI渲染线程**，渲染页面
4. 渲染页面结束后，**从宏任务队列中取出一个宏任务放入执行栈中执行**
5. 再次执行**js**引擎线程，重复以上步骤
  
## 样例一
{% codeblock lang:js %}

{% endcodeblock %}
1. 1
2. 2
3. 3
4. 4
5. 5
> 引用

## 样例二
{% codeblock lang:js %}

{% endcodeblock %}
1. 1
2. 2
3. 3
4. 4
5. 5
> 引用

## 样例三
{% codeblock lang:js %}

{% endcodeblock %}
1. 1
2. 2
3. 3
4. 4
5. 5
> 引用

## 样例四
{% codeblock lang:js %}

{% endcodeblock %}
1. 1
2. 2
3. 3
4. 4
5. 5
> 引用

## 样例五
{% codeblock lang:js %}

{% endcodeblock %}
1. 1
2. 2
3. 3
4. 4
5. 5
> 引用